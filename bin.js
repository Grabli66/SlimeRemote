// Generated by Haxe 3.4.0
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var BinaryData = function(data) {
	this._buffer = [];
	if(data != null) {
		this._buffer = data;
	}
};
$hxClasses["BinaryData"] = BinaryData;
BinaryData.__name__ = ["BinaryData"];
BinaryData.FromArray = function(data) {
	return new BinaryData(data);
};
BinaryData.ConvertToArrayUInt8 = function(data) {
	var dat = js_Boot.__cast(data.b.bufferValue , Uint8Array);
	var arr = [];
	var _g = 0;
	while(_g < dat.length) {
		var b = dat[_g];
		++_g;
		arr.push(b & 255);
	}
	return arr;
};
BinaryData.ConvertToArrayBuffer = function(data) {
	return haxe_io_Bytes.ofData(js_Boot.__cast(new Uint8Array(data) , ArrayBuffer));
};
BinaryData.RandomBytes = function(len) {
	var res = [];
	var _g1 = 0;
	while(_g1 < len) {
		++_g1;
		res.push(Math.round(Math.random() * 255) & 255);
	}
	return res;
};
BinaryData.FromBytes = function(data) {
	var dat = js_Boot.__cast(data.b.bufferValue , Uint8Array);
	var arr = [];
	var _g = 0;
	while(_g < dat.length) {
		var b = dat[_g];
		++_g;
		arr.push(b & 255);
	}
	return new BinaryData(arr);
};
BinaryData.FromArrayBuffer = function(data) {
	var dat = new Uint8Array(data);
	var arr = [];
	var _g = 0;
	while(_g < dat.length) {
		var b = dat[_g];
		++_g;
		arr.push(b & 255);
	}
	return new BinaryData(arr);
};
BinaryData.prototype = {
	iterator: function() {
		return HxOverrides.iter(this._buffer);
	}
	,AddBinaryData: function(data) {
		var b = data.iterator();
		while(b.hasNext()) {
			var b1 = b.next();
			this._buffer.push(b1);
		}
	}
	,AddArray: function(data) {
		var _g = 0;
		while(_g < data.length) {
			var b = data[_g];
			++_g;
			this._buffer.push(b);
		}
	}
	,AddBytes: function(data) {
		var dat = js_Boot.__cast(data.b.bufferValue , Uint8Array);
		var arr = [];
		var _g = 0;
		while(_g < dat.length) {
			var b = dat[_g];
			++_g;
			arr.push(b & 255);
		}
		this.AddArray(arr);
	}
	,AddUint8: function(b) {
		this._buffer.push(b);
	}
	,AddUint16: function(b) {
		this._buffer.push((b & 65280) >> 8 & 255);
		this._buffer.push(b & 255 & 255);
	}
	,AddUint32: function(b) {
		this._buffer.push((b & -16777216) >> 24 & 255);
		this._buffer.push((b & 16711680) >> 16 & 255);
		this._buffer.push((b & 65280) >> 8 & 255);
		this._buffer.push(b & 255 & 255);
	}
	,AddString: function(s) {
		var _gthis = this;
		haxe_Utf8.iter(haxe_Utf8.encode(s),function(b) {
			_gthis._buffer.push(b & 255);
		});
		this._buffer.push(0);
	}
	,GetUint8: function(pos) {
		return this._buffer[pos];
	}
	,GetUint16: function(pos) {
		return (this._buffer[pos] << 8) + this._buffer[pos + 1] & 65535;
	}
	,GetUint32: function(pos) {
		return (this._buffer[pos] << 24) + (this._buffer[pos + 1] << 16) + (this._buffer[pos + 2] << 8) + this._buffer[pos + 3] & -1;
	}
	,GetString: function(pos) {
		var utf = new haxe_Utf8();
		var _g1 = pos;
		var _g = this._buffer.length;
		while(_g1 < _g) {
			var b = this._buffer[_g1++];
			if(b == 0) {
				break;
			}
			utf.__b += String.fromCharCode(b);
		}
		return haxe_Utf8.decode(utf.__b);
	}
	,GetArray: function(pos,len) {
		var res = [];
		var _g1 = pos;
		var _g = pos + len;
		while(_g1 < _g) res.push(this._buffer[_g1++]);
		return res;
	}
	,Length: function() {
		return this._buffer.length & -1;
	}
	,Cut: function(pos,len) {
		return new BinaryData(this._buffer.splice(pos,len));
	}
	,ToArray: function() {
		return this._buffer;
	}
	,ToBytes: function() {
		return haxe_io_Bytes.ofData(js_Boot.__cast(new Uint8Array(this._buffer) , ArrayBuffer));
	}
	,ToArrayBufferView: function() {
		return new Uint8Array(this._buffer);
	}
	,__class__: BinaryData
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var _$KnownType_KnownType_$Impl_$ = {};
$hxClasses["_KnownType.KnownType_Impl_"] = _$KnownType_KnownType_$Impl_$;
_$KnownType_KnownType_$Impl_$.__name__ = ["_KnownType","KnownType_Impl_"];
_$KnownType_KnownType_$Impl_$._new = function(v) {
	if([3,4,0,1,2,6,5].indexOf(v) < 0) {
		throw new js__$Boot_HaxeError("Wrong value");
	}
	return v;
};
_$KnownType_KnownType_$Impl_$.FromInt = function(v) {
	if([3,4,0,1,2,6,5].indexOf(v) < 0) {
		throw new js__$Boot_HaxeError("Wrong value");
	}
	return v;
};
_$KnownType_KnownType_$Impl_$.FromString = function(v) {
	switch(v) {
	case "Array":
		if([3,4,0,1,2,6,5].indexOf(5) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 5;
	case "Int":
		if([3,4,0,1,2,6,5].indexOf(3) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 3;
	case "SlimePacket":
		if([3,4,0,1,2,6,5].indexOf(6) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 6;
	case "String":
		if([3,4,0,1,2,6,5].indexOf(4) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 4;
	case "UInt16":
		if([3,4,0,1,2,6,5].indexOf(1) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 1;
	case "UInt32":
		if([3,4,0,1,2,6,5].indexOf(2) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 2;
	case "UInt8":
		if([3,4,0,1,2,6,5].indexOf(0) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return 0;
	default:
		throw new js__$Boot_HaxeError("Wrong type");
	}
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = ["Lambda"];
Lambda.array = function(it) {
	var a = [];
	var i = $iterator(it)();
	while(i.hasNext()) a.push(i.next());
	return a;
};
Math.__name__ = ["Math"];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var SlimePacket = function() {
};
$hxClasses["SlimePacket"] = SlimePacket;
SlimePacket.__name__ = ["SlimePacket"];
SlimePacket.prototype = {
	GetName: function() {
		return "SlimePacket";
	}
	,GetValues: function() {
		return null;
	}
	,GetNames: function() {
		return null;
	}
	,__class__: SlimePacket
};
var SlimePacketParser = function() { };
$hxClasses["SlimePacketParser"] = SlimePacketParser;
SlimePacketParser.__name__ = ["SlimePacketParser"];
SlimePacketParser.AddPacket = function(data,out) {
	if(data == null) {
		out.AddUint8(255);
		return;
	}
	out.AddUint8(2);
	var name = data.GetName();
	var _this = SlimePacketParser._knownPackets;
	out.AddUint8(__map_reserved[name] != null?_this.getReserved(name):_this.h[name]);
	var vals = data.GetValues();
	out.AddUint8(vals.length & 255);
	var _g = 0;
	while(_g < vals.length) {
		var v = vals[_g];
		++_g;
		SlimePacketParser.AddData(v,out);
	}
};
SlimePacketParser.AddUInt8 = function(data,out) {
	out.AddUint8(3);
	out.AddUint8(data.Value);
};
SlimePacketParser.AddUInt16 = function(data,out) {
	out.AddUint8(4);
	out.AddUint16(data.Value);
};
SlimePacketParser.AddUInt32 = function(data,out) {
	out.AddUint8(5);
	out.AddUint32(data.Value);
};
SlimePacketParser.AddArray = function(data,out) {
	var typeInfo = data.VarInfo.TypeInfo.Param;
	if(data.VarInfo.TypeInfo.Param == null) {
		throw new js__$Boot_HaxeError("Wrong array");
	}
	var value = data.Value;
	out.AddUint8(1);
	out.AddUint8(value.length & 255);
	var _g = 0;
	while(_g < value.length) {
		var v = value[_g];
		++_g;
		SlimePacketParser.AddData({ VarInfo : { Name : "", TypeInfo : typeInfo}, Value : v},out);
	}
};
SlimePacketParser.AddData = function(data,out) {
	var typeId = data.VarInfo.TypeInfo.Id;
	if(typeId == 6) {
		SlimePacketParser.AddPacket(data.Value,out);
	} else if(typeId == 0) {
		SlimePacketParser.AddUInt8(data,out);
	} else if(typeId == 1) {
		SlimePacketParser.AddUInt16(data,out);
	} else if(typeId == 2) {
		SlimePacketParser.AddUInt32(data,out);
	} else if(typeId == 3) {
		SlimePacketParser.AddUInt32(data,out);
	} else if(typeId == 5) {
		SlimePacketParser.AddArray(data,out);
	} else {
		throw new js__$Boot_HaxeError("Unsupported data");
	}
};
SlimePacketParser.GetPacket = function(data,pos) {
	var packType = data.GetUint8(pos);
	++pos;
	var pack = Type.createInstance(SlimePacketParser._knownPacketsResolved.h[packType],[]);
	if(pack == null) {
		throw new js__$Boot_HaxeError("Unknown packet");
	}
	var count = data.GetUint8(pos);
	++pos;
	var names = pack.GetNames();
	if(count != names.length) {
		throw new js__$Boot_HaxeError("Wrong data");
	}
	var _g1 = 0;
	var _g = count;
	while(_g1 < _g) {
		var dat = SlimePacketParser.GetType(data,pos);
		pos = dat.Pos;
		pack[names[_g1++].Name] = dat.Data;
	}
	return { Packet : pack, Pos : pos};
};
SlimePacketParser.GetArray = function(data,pos) {
	var count = data.GetUint8(pos);
	++pos;
	var res = [];
	var _g1 = 0;
	var _g = count;
	while(_g1 < _g) {
		++_g1;
		var tp = SlimePacketParser.GetType(data,pos);
		pos = tp.Pos;
		res.push(tp.Data);
	}
	return { Data : res, Pos : pos};
};
SlimePacketParser.GetType = function(data,pos) {
	var type = data.GetUint8(pos);
	++pos;
	var dat;
	switch(type) {
	case 1:
		var arr = SlimePacketParser.GetArray(data,pos);
		dat = arr.Data;
		pos = arr.Pos;
		break;
	case 2:
		var stru = SlimePacketParser.GetPacket(data,pos);
		dat = stru.Packet;
		pos = stru.Pos;
		break;
	case 3:
		dat = data.GetUint8(pos);
		++pos;
		break;
	case 4:
		dat = data.GetUint16(pos);
		pos += 2;
		break;
	case 5:
		dat = data.GetUint32(pos);
		pos += 4;
		break;
	case 255:
		dat = null;
		break;
	default:
		throw new js__$Boot_HaxeError("Unknown type: " + type);
	}
	return { Data : dat, Pos : pos};
};
SlimePacketParser.Register = function(name) {
	var v = SlimePacketParser._counter & 255;
	var _this = SlimePacketParser._knownPackets;
	if(__map_reserved[name] != null) {
		_this.setReserved(name,v);
	} else {
		_this.h[name] = v;
	}
	var this1 = SlimePacketParser._knownPacketsResolved;
	var this2 = SlimePacketParser._counter & 255;
	var v1 = Type.resolveClass(name);
	this1.h[this2] = v1;
	SlimePacketParser._counter++;
	return 0;
};
SlimePacketParser.ToBinary = function(data) {
	var res = new BinaryData();
	SlimePacketParser.AddPacket(data,res);
	return res;
};
SlimePacketParser.FromBinary = function(data) {
	return SlimePacketParser.GetType(data,0).Data;
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var hxbit_Serializable = function() { };
$hxClasses["hxbit.Serializable"] = hxbit_Serializable;
hxbit_Serializable.__name__ = ["hxbit","Serializable"];
hxbit_Serializable.prototype = {
	__class__: hxbit_Serializable
};
var hxbit_Serializer = function() {
	this.usedClasses = [];
	if(hxbit_Serializer.CLIDS == null) {
		hxbit_Serializer.initClassIDS();
	}
};
$hxClasses["hxbit.Serializer"] = hxbit_Serializer;
hxbit_Serializer.__name__ = ["hxbit","Serializer"];
hxbit_Serializer.resetCounters = function() {
	hxbit_Serializer.UID = 0;
	hxbit_Serializer.SEQ = 0;
};
hxbit_Serializer.allocUID = function() {
	return hxbit_Serializer.SEQ << 24 | ++hxbit_Serializer.UID;
};
hxbit_Serializer.registerClass = function(c) {
	if(hxbit_Serializer.CLIDS != null) {
		throw new js__$Boot_HaxeError("Too late to register class");
	}
	var idx = hxbit_Serializer.CLASSES.length;
	hxbit_Serializer.CLASSES.push(c);
	return idx;
};
hxbit_Serializer.initClassIDS = function() {
	var cl = hxbit_Serializer.CLASSES;
	var _g = [];
	var _g1 = 0;
	while(_g1 < cl.length) {
		++_g1;
		_g.push([]);
	}
	var isSub = [];
	var _g2 = 0;
	var _g11 = cl.length;
	while(_g2 < _g11) {
		var i = _g2++;
		var c = cl[i];
		while(true) {
			c = Type.getSuperClass(c);
			if(c == null) {
				break;
			}
			var idx = cl.indexOf(c);
			if(idx < 0) {
				break;
			}
			_g[idx].push(i);
			isSub[i] = true;
		}
	}
	var _g12 = [];
	var _g3 = 0;
	var _g21 = hxbit_Serializer.CLASSES.length;
	while(_g3 < _g21) {
		var i1 = _g3++;
		var tmp;
		if(_g[i1].length == 0 && !isSub[i1]) {
			tmp = 0;
		} else {
			var name = Type.getClassName(cl[i1]);
			var v = 1;
			var _g22 = 0;
			var _g13 = name.length;
			while(_g22 < _g13) v = v * 223 + name.charCodeAt(_g22++);
			v = 1 + (v & 1073741823) % 65423;
			tmp = v;
		}
		_g12.push(tmp);
	}
	hxbit_Serializer.CLIDS = _g12;
	hxbit_Serializer.CL_BYID = [];
	var _g31 = 0;
	var _g23 = hxbit_Serializer.CLIDS.length;
	while(_g31 < _g23) {
		var i2 = _g31++;
		var cid = hxbit_Serializer.CLIDS[i2];
		if(cid == 0) {
			continue;
		}
		if(hxbit_Serializer.CL_BYID[cid] != null) {
			throw new js__$Boot_HaxeError("Conflicting CLID between " + Type.getClassName(hxbit_Serializer.CL_BYID[cid]) + " and " + Type.getClassName(cl[i2]));
		}
		hxbit_Serializer.CL_BYID[cid] = cl[i2];
	}
};
hxbit_Serializer.isClassFinal = function(index) {
	return hxbit_Serializer.CLIDS[index] == 0;
};
hxbit_Serializer.prototype = {
	begin: function() {
		this.out = new haxe_io_BytesBuffer();
		this.refs = new haxe_ds_IntMap();
	}
	,end: function() {
		var bytes = this.out.getBytes();
		this.out = null;
		this.refs = null;
		return bytes;
	}
	,setInput: function(data,pos) {
		this.input = data;
		this.inPos = pos;
	}
	,serialize: function(s) {
		this.begin();
		this.addKnownRef(s);
		return this.out.getBytes();
	}
	,unserialize: function(data,c,startPos) {
		if(startPos == null) {
			startPos = 0;
		}
		this.refs = new haxe_ds_IntMap();
		this.setInput(data,startPos);
		return this.getRef(c,c.__clid);
	}
	,getByte: function() {
		return this.input.b[this.inPos++];
	}
	,addByte: function(v) {
		this.out.b.push(v);
	}
	,addInt: function(v) {
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
	}
	,addInt32: function(v) {
		this.out.addInt32(v);
	}
	,addFloat: function(v) {
		this.out.addInt32(haxe_io_FPHelper.floatToI32(v));
	}
	,addDouble: function(v) {
		this.out.addInt64(haxe_io_FPHelper.doubleToI64(v));
	}
	,addBool: function(v) {
		this.out.b.push(v?1:0);
	}
	,addArray: function(a,f) {
		if(a == null) {
			this.out.b.push(0);
			return;
		}
		var v = a.length + 1;
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
		var _g = 0;
		while(_g < a.length) {
			var v1 = a[_g];
			++_g;
			f(v1);
		}
	}
	,addVector: function(a,f) {
		if(a == null) {
			this.out.b.push(0);
			return;
		}
		var v = a.length + 1;
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
		var _g = 0;
		while(_g < a.length) {
			var v1 = a[_g];
			++_g;
			f(v1);
		}
	}
	,getArray: function(f) {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var len = v;
		if(len == 0) {
			return null;
		}
		--len;
		var a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) a[_g1++] = f();
		return a;
	}
	,getVector: function(f) {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var len = v;
		if(len == 0) {
			return null;
		}
		--len;
		var a = new Array(len);
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) a[_g1++] = f();
		return a;
	}
	,addMap: function(a,fk,ft) {
		if(a == null) {
			this.out.b.push(0);
			return;
		}
		var _e = a;
		var keys = Lambda.array({ iterator : function() {
			return _e.keys();
		}});
		this.out.b.push(keys.length + 1);
		var _g = 0;
		while(_g < keys.length) {
			var k = keys[_g];
			++_g;
			fk(k);
			ft(a.get(k));
		}
	}
	,getBool: function() {
		return this.input.b[this.inPos++] != 0;
	}
	,getInt: function() {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		return v;
	}
	,getInt32: function() {
		var v = this.input.getInt32(this.inPos);
		this.inPos += 4;
		return v;
	}
	,getDouble: function() {
		var v = this.input.getDouble(this.inPos);
		this.inPos += 8;
		return v;
	}
	,getFloat: function() {
		var v = this.input.getFloat(this.inPos);
		this.inPos += 4;
		return v;
	}
	,addString: function(s) {
		if(s == null) {
			this.out.b.push(0);
		} else {
			var b = haxe_io_Bytes.ofString(s);
			var v = b.length + 1;
			if(v >= 0 && v < 128) {
				this.out.b.push(v);
			} else {
				this.out.b.push(128);
				this.out.addInt32(v);
			}
			var _this = this.out;
			var b2 = b.b;
			var _g1 = 0;
			var _g = b.length;
			while(_g1 < _g) _this.b.push(b2[_g1++]);
		}
	}
	,addBytes: function(b) {
		if(b == null) {
			this.out.b.push(0);
		} else {
			var v = b.length + 1;
			if(v >= 0 && v < 128) {
				this.out.b.push(v);
			} else {
				this.out.b.push(128);
				this.out.addInt32(v);
			}
			var _this = this.out;
			var b2 = b.b;
			var _g1 = 0;
			var _g = b.length;
			while(_g1 < _g) _this.b.push(b2[_g1++]);
		}
	}
	,getString: function() {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var len = v;
		if(len == 0) {
			return null;
		}
		--len;
		var s = this.input.getString(this.inPos,len);
		this.inPos += len;
		return s;
	}
	,getBytes: function() {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var len = v;
		if(len == 0) {
			return null;
		}
		--len;
		var s = this.input.sub(this.inPos,len);
		this.inPos += len;
		return s;
	}
	,getDynamic: function() {
		var _g = this.input.b[this.inPos++];
		switch(_g) {
		case 0:
			return null;
		case 1:
			return false;
		case 2:
			return true;
		case 3:
			var v = this.input.b[this.inPos++];
			if(v == 128) {
				v = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			return v;
		case 4:
			var v1 = this.input.getFloat(this.inPos);
			this.inPos += 4;
			return v1;
		case 5:
			var o = { };
			var _g1 = 0;
			var v2 = this.input.b[this.inPos++];
			if(v2 == 128) {
				v2 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var _g2 = v2;
			while(_g1 < _g2) {
				++_g1;
				var v3 = this.input.b[this.inPos++];
				if(v3 == 128) {
					v3 = this.input.getInt32(this.inPos);
					this.inPos += 4;
				}
				var len = v3;
				var field;
				if(len == 0) {
					field = null;
				} else {
					--len;
					var s = this.input.getString(this.inPos,len);
					this.inPos += len;
					field = s;
				}
				o[field] = this.getDynamic();
			}
			return o;
		case 6:
			var v4 = this.input.b[this.inPos++];
			if(v4 == 128) {
				v4 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len1 = v4;
			if(len1 == 0) {
				return null;
			} else {
				--len1;
				var s1 = this.input.getString(this.inPos,len1);
				this.inPos += len1;
				return s1;
			}
			break;
		case 7:
			var _g3 = [];
			var _g21 = 0;
			var v5 = this.input.b[this.inPos++];
			if(v5 == 128) {
				v5 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var _g11 = v5;
			while(_g21 < _g11) {
				++_g21;
				_g3.push(this.getDynamic());
			}
			return _g3;
		case 8:
			var v6 = this.input.b[this.inPos++];
			if(v6 == 128) {
				v6 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len2 = v6;
			if(len2 == 0) {
				return null;
			} else {
				--len2;
				var s2 = this.input.sub(this.inPos,len2);
				this.inPos += len2;
				return s2;
			}
			break;
		default:
			throw new js__$Boot_HaxeError("Invalid dynamic prefix " + _g);
		}
	}
	,addDynamic: function(v) {
		if(v == null) {
			this.out.b.push(0);
			return;
		}
		var _g = Type["typeof"](v);
		switch(_g[1]) {
		case 1:
			this.out.b.push(3);
			var v1 = v;
			if(v1 >= 0 && v1 < 128) {
				this.out.b.push(v1);
			} else {
				this.out.b.push(128);
				this.out.addInt32(v1);
			}
			break;
		case 2:
			this.out.b.push(4);
			this.out.addInt32(haxe_io_FPHelper.floatToI32(v));
			break;
		case 3:
			this.out.b.push(v?2:1);
			break;
		case 4:
			var fields = Reflect.fields(v);
			this.out.b.push(5);
			var v2 = fields.length;
			if(v2 >= 0 && v2 < 128) {
				this.out.b.push(v2);
			} else {
				this.out.b.push(128);
				this.out.addInt32(v2);
			}
			var _g1 = 0;
			while(_g1 < fields.length) {
				var f = fields[_g1];
				++_g1;
				if(f == null) {
					this.out.b.push(0);
				} else {
					var b = haxe_io_Bytes.ofString(f);
					var v3 = b.length + 1;
					if(v3 >= 0 && v3 < 128) {
						this.out.b.push(v3);
					} else {
						this.out.b.push(128);
						this.out.addInt32(v3);
					}
					var _this = this.out;
					var b2 = b.b;
					var _g11 = 0;
					var _g2 = b.length;
					while(_g11 < _g2) _this.b.push(b2[_g11++]);
				}
				this.addDynamic(Reflect.field(v,f));
			}
			break;
		case 6:
			var c = _g[2];
			switch(c) {
			case Array:
				this.out.b.push(7);
				var a = v;
				var v4 = a.length;
				if(v4 >= 0 && v4 < 128) {
					this.out.b.push(v4);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v4);
				}
				var _g3 = 0;
				while(_g3 < a.length) {
					var v5 = a[_g3];
					++_g3;
					this.addDynamic(v5);
				}
				break;
			case String:
				this.out.b.push(6);
				var s = v;
				if(s == null) {
					this.out.b.push(0);
				} else {
					var b1 = haxe_io_Bytes.ofString(s);
					var v6 = b1.length + 1;
					if(v6 >= 0 && v6 < 128) {
						this.out.b.push(v6);
					} else {
						this.out.b.push(128);
						this.out.addInt32(v6);
					}
					var _this1 = this.out;
					var b21 = b1.b;
					var _g12 = 0;
					var _g4 = b1.length;
					while(_g12 < _g4) _this1.b.push(b21[_g12++]);
				}
				break;
			case haxe_io_Bytes:
				this.out.b.push(8);
				var b3 = v;
				if(b3 == null) {
					this.out.b.push(0);
				} else {
					var v7 = b3.length + 1;
					if(v7 >= 0 && v7 < 128) {
						this.out.b.push(v7);
					} else {
						this.out.b.push(128);
						this.out.addInt32(v7);
					}
					var _this2 = this.out;
					var b22 = b3.b;
					var _g13 = 0;
					var _g5 = b3.length;
					while(_g13 < _g5) _this2.b.push(b22[_g13++]);
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Unsupported dynamic " + Std.string(c));
			}
			break;
		default:
			throw new js__$Boot_HaxeError("Unsupported dynamic " + Std.string(_g));
		}
	}
	,addCLID: function(clid) {
		this.out.b.push(clid >> 8);
		this.out.b.push(clid & 255);
	}
	,getCLID: function() {
		return this.input.b[this.inPos++] << 8 | this.input.b[this.inPos++];
	}
	,addAnyRef: function(s) {
		if(s == null) {
			this.out.b.push(0);
			return;
		}
		var v = s.__uid;
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
		if(this.refs.h[s.__uid] != null) {
			return;
		}
		this.refs.h[s.__uid] = s;
		var index = s.getCLID();
		this.usedClasses[index] = true;
		this.out.b.push(index >> 8);
		this.out.b.push(index & 255);
		s.serialize(this);
	}
	,addKnownRef: function(s) {
		if(s == null) {
			this.out.b.push(0);
			return;
		}
		var v = s.__uid;
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
		if(this.refs.h[s.__uid] != null) {
			return;
		}
		this.refs.h[s.__uid] = s;
		var index = s.getCLID();
		this.usedClasses[index] = true;
		var clid = hxbit_Serializer.CLIDS[index];
		if(clid != 0) {
			this.out.b.push(clid >> 8);
			this.out.b.push(clid & 255);
		}
		s.serialize(this);
	}
	,getAnyRef: function() {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var id = v;
		if(id == 0) {
			return null;
		}
		if(this.refs.h[id] != null) {
			return this.refs.h[id];
		}
		var rid = id & 16777215;
		if(hxbit_Serializer.UID < rid) {
			hxbit_Serializer.UID = rid;
		}
		var clidx = this.input.b[this.inPos++] << 8 | this.input.b[this.inPos++];
		if(this.mapIndexes != null) {
			clidx = this.mapIndexes[clidx];
		}
		var i = Type.createEmptyInstance(hxbit_Serializer.CLASSES[clidx]);
		if(this.newObjects != null) {
			this.newObjects.push(i);
		}
		i.__uid = id;
		i.unserializeInit();
		this.refs.h[id] = i;
		if(this.convert != null && this.convert[clidx] != null) {
			this.convertRef(i,this.convert[clidx]);
		} else {
			i.unserialize(this);
		}
		return i;
	}
	,getRef: function(c,clidx) {
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var id = v;
		if(id == 0) {
			return null;
		}
		if(this.refs.h[id] != null) {
			return this.refs.h[id];
		}
		var rid = id & 16777215;
		if(hxbit_Serializer.UID < rid) {
			hxbit_Serializer.UID = rid;
		}
		if(hxbit_Serializer.CLIDS[clidx] != 0) {
			var realIdx = this.input.b[this.inPos++] << 8 | this.input.b[this.inPos++];
			c = hxbit_Serializer.CL_BYID[realIdx];
			if(this.convert != null) {
				clidx = c.__clid;
			}
		}
		var i = Type.createEmptyInstance(c);
		if(this.newObjects != null) {
			this.newObjects.push(i);
		}
		i.__uid = id;
		i.unserializeInit();
		this.refs.h[id] = i;
		if(this.convert != null && this.convert[clidx] != null) {
			this.convertRef(i,this.convert[clidx]);
		} else {
			i.unserialize(this);
		}
		return i;
	}
	,getKnownRef: function(c) {
		return this.getRef(c,c.__clid);
	}
	,beginSave: function() {
		this.begin();
		this.usedClasses = [];
	}
	,endSave: function() {
		var content = this.end();
		this.begin();
		var classes = [];
		var schemas = [];
		var sidx = hxbit_Serializer.CLASSES.indexOf(hxbit_Schema);
		var _g1 = 0;
		var _g = this.usedClasses.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!this.usedClasses[i] || i == sidx) {
				continue;
			}
			var schema = Type.createEmptyInstance(hxbit_Serializer.CLASSES[i]).getSerializeSchema();
			schemas.push(schema);
			classes.push(i);
			this.addKnownRef(schema);
			this.refs.remove(schema.__uid);
		}
		var schemaData = this.end();
		this.begin();
		var b = haxe_io_Bytes.ofString("HXS");
		var v = b.length + 1;
		if(v >= 0 && v < 128) {
			this.out.b.push(v);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v);
		}
		var _this = this.out;
		var b2 = b.b;
		var _g11 = 0;
		var _g2 = b.length;
		while(_g11 < _g2) _this.b.push(b2[_g11++]);
		this.out.b.push(1);
		var _g12 = 0;
		var _g3 = classes.length;
		while(_g12 < _g3) {
			var i1 = _g12++;
			var index = classes[i1];
			var s = Type.getClassName(hxbit_Serializer.CLASSES[index]);
			if(s == null) {
				this.out.b.push(0);
			} else {
				var b1 = haxe_io_Bytes.ofString(s);
				var v1 = b1.length + 1;
				if(v1 >= 0 && v1 < 128) {
					this.out.b.push(v1);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v1);
				}
				var _this1 = this.out;
				var b21 = b1.b;
				var _g13 = 0;
				var _g4 = b1.length;
				while(_g13 < _g4) _this1.b.push(b21[_g13++]);
			}
			this.out.b.push(index >> 8);
			this.out.b.push(index & 255);
			var v2 = schemas[i1].get_checkSum();
			this.out.addInt32(v2);
		}
		this.out.b.push(0);
		var v3 = schemaData.length;
		if(v3 >= 0 && v3 < 128) {
			this.out.b.push(v3);
		} else {
			this.out.b.push(128);
			this.out.addInt32(v3);
		}
		var _this2 = this.out;
		var b22 = schemaData.b;
		var _g14 = 0;
		var _g5 = schemaData.length;
		while(_g14 < _g5) _this2.b.push(b22[_g14++]);
		var _this3 = this.out;
		var b23 = content.b;
		var _g15 = 0;
		var _g6 = content.length;
		while(_g15 < _g6) _this3.b.push(b23[_g15++]);
		return this.end();
	}
	,beginLoad: function(bytes,position) {
		if(position == null) {
			position = 0;
		}
		this.setInput(bytes,position);
		var classByName = new haxe_ds_StringMap();
		var schemas = [];
		var mapIndexes = [];
		var indexes = [];
		var needConvert = false;
		var needReindex = false;
		var _g1 = 0;
		var _g = hxbit_Serializer.CLASSES.length;
		while(_g1 < _g) {
			var i = _g1++;
			var key = Type.getClassName(hxbit_Serializer.CLASSES[i]);
			if(__map_reserved[key] != null) {
				classByName.setReserved(key,i);
			} else {
				classByName.h[key] = i;
			}
			mapIndexes[i] = i;
		}
		var v = this.input.b[this.inPos++];
		if(v == 128) {
			v = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var len = v;
		var tmp;
		if(len == 0) {
			tmp = null;
		} else {
			--len;
			var s = this.input.getString(this.inPos,len);
			this.inPos += len;
			tmp = s;
		}
		if(tmp != "HXS") {
			throw new js__$Boot_HaxeError("Invalid HXS data");
		}
		var version = this.input.b[this.inPos++];
		if(version != 1) {
			throw new js__$Boot_HaxeError("Unsupported HXS version " + version);
		}
		while(true) {
			var v1 = this.input.b[this.inPos++];
			if(v1 == 128) {
				v1 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len1 = v1;
			var clname;
			if(len1 == 0) {
				clname = null;
			} else {
				--len1;
				var s1 = this.input.getString(this.inPos,len1);
				this.inPos += len1;
				clname = s1;
			}
			if(clname == null) {
				break;
			}
			var index = this.input.b[this.inPos++] << 8 | this.input.b[this.inPos++];
			var v2 = this.input.getInt32(this.inPos);
			this.inPos += 4;
			var ourClassIndex = __map_reserved[clname] != null?classByName.getReserved(clname):classByName.h[clname];
			if(ourClassIndex == null) {
				throw new js__$Boot_HaxeError("Missing class " + clname + " found in HXS data");
			}
			var ourSchema = Type.createEmptyInstance(hxbit_Serializer.CLASSES[ourClassIndex]).getSerializeSchema();
			if(ourSchema.get_checkSum() != v2) {
				needConvert = true;
				schemas[index] = ourSchema;
			}
			if(index != ourClassIndex) {
				needReindex = true;
				mapIndexes[index] = ourClassIndex;
			}
			indexes.push(index);
		}
		var v3 = this.input.b[this.inPos++];
		if(v3 == 128) {
			v3 = this.input.getInt32(this.inPos);
			this.inPos += 4;
		}
		var schemaDataSize = v3;
		if(needConvert) {
			this.convert = [];
			var _g2 = 0;
			while(_g2 < indexes.length) {
				var index1 = indexes[_g2];
				++_g2;
				var ourSchema1 = schemas[index1];
				var c = hxbit_Schema;
				var schema = this.getRef(c,c.__clid);
				this.refs.remove(schema.__uid);
				if(ourSchema1 != null) {
					this.convert[mapIndexes[index1]] = new hxbit_Convert(ourSchema1,schema);
				}
			}
		} else {
			this.inPos += schemaDataSize;
		}
		if(needReindex) {
			this.mapIndexes = mapIndexes;
		}
	}
	,endLoad: function() {
		this.convert = null;
		this.mapIndexes = null;
		this.setInput(null,0);
	}
	,convertRef: function(i,c) {
		var length = c.read.length;
		var values = new Array(length);
		var _g = 0;
		var _g1 = c.read;
		while(_g < _g1.length) {
			var r = _g1[_g];
			++_g;
			values[r.index] = this.readValue(r.from);
		}
		var oldOut = this.out;
		this.out = new haxe_io_BytesBuffer();
		var _g2 = 0;
		var _g11 = c.write;
		while(_g2 < _g11.length) {
			var w = _g11[_g2];
			++_g2;
			var v;
			if(w.from == null) {
				v = w.defaultValue;
			} else {
				v = values[w.index];
				if(!w.same) {
					if(v == null) {
						v = w.defaultValue;
					} else {
						v = this.convertValue(v,w.from,w.to);
					}
				}
			}
			this.writeValue(v,w.to);
		}
		var bytes = this.out.getBytes();
		this.out = oldOut;
		var oldIn = this.input;
		var oldPos = this.inPos;
		this.setInput(bytes,0);
		i.unserialize(this);
		this.setInput(oldIn,oldPos);
	}
	,isNullable: function(t) {
		switch(t[1]) {
		case 0:case 1:case 2:
			return false;
		default:
			return true;
		}
	}
	,convertValue: function(v,from,to) {
		if(v == null && this.isNullable(to)) {
			return null;
		}
		if(hxbit_Convert.sameType(from,to)) {
			return v;
		}
		if(from[1] == 9) {
			if(to[1] == 9) {
				var obj1 = from[2];
				var obj2 = to[2];
				var v2 = { };
				var _g = 0;
				while(_g < obj2.length) {
					var f = obj2[_g];
					++_g;
					var found = false;
					var field = null;
					var _g1 = 0;
					while(_g1 < obj1.length) {
						var f2 = obj1[_g1];
						++_g1;
						if(f2.name == f.name) {
							found = true;
							field = this.convertValue(Reflect.field(v,f2.name),f2.type,f.type);
							break;
						}
					}
					if(!found) {
						if(f.opt) {
							continue;
						}
						field = hxbit_Convert.getDefault(f.type);
					} else if(field == null && f.opt) {
						continue;
					}
					v2[f.name] = field;
				}
				return v2;
			}
		}
		throw new js__$Boot_HaxeError("Cannot convert " + Std.string(v) + " from " + Std.string(from) + " to " + Std.string(to));
	}
	,readValue: function(t) {
		var _gthis = this;
		switch(t[1]) {
		case 0:
			var v = this.input.b[this.inPos++];
			if(v == 128) {
				v = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			return v;
		case 1:
			var v1 = this.input.getFloat(this.inPos);
			this.inPos += 4;
			return v1;
		case 2:
			return this.input.b[this.inPos++] != 0;
		case 3:
			var v2 = this.input.b[this.inPos++];
			if(v2 == 128) {
				v2 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len = v2;
			if(len == 0) {
				return null;
			} else {
				--len;
				var s = this.input.getString(this.inPos,len);
				this.inPos += len;
				return s;
			}
			break;
		case 4:
			var v3 = this.input.b[this.inPos++];
			if(v3 == 128) {
				v3 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len1 = v3;
			if(len1 == 0) {
				return null;
			} else {
				--len1;
				var s1 = this.input.sub(this.inPos,len1);
				this.inPos += len1;
				return s1;
			}
			break;
		case 5:
			return this.getKnownRef(Type.resolveClass(t[2]));
		case 6:
			var name = t[2];
			var ser = "hxbit.enumSer." + name.split(".").join("_");
			if(ser == null) {
				throw new js__$Boot_HaxeError("No enum unserializer found for " + name);
			}
			return Type.resolveClass(ser).doUnserialize(this);
		case 7:
			var v4 = t[3];
			var k = t[2];
			switch(k[1]) {
			case 0:
				var v5 = this.input.b[this.inPos++];
				if(v5 == 128) {
					v5 = this.input.getInt32(this.inPos);
					this.inPos += 4;
				}
				var len2 = v5;
				var tmp;
				if(len2 == 0) {
					tmp = null;
				} else {
					var m = new haxe_ds_IntMap();
					while(--len2 > 0) {
						var k1 = _gthis.readValue(k);
						var v6 = _gthis.readValue(v4);
						m.h[k1] = v6;
					}
					tmp = m;
				}
				return tmp;
			case 3:
				var v7 = this.input.b[this.inPos++];
				if(v7 == 128) {
					v7 = this.input.getInt32(this.inPos);
					this.inPos += 4;
				}
				var len3 = v7;
				var tmp1;
				if(len3 == 0) {
					tmp1 = null;
				} else {
					var m1 = new haxe_ds_StringMap();
					while(--len3 > 0) {
						var k2 = _gthis.readValue(k);
						var v8 = _gthis.readValue(v4);
						if(__map_reserved[k2] != null) {
							m1.setReserved(k2,v8);
						} else {
							m1.h[k2] = v8;
						}
					}
					tmp1 = m1;
				}
				return tmp1;
			default:
				var v9 = this.input.b[this.inPos++];
				if(v9 == 128) {
					v9 = this.input.getInt32(this.inPos);
					this.inPos += 4;
				}
				var len4 = v9;
				var tmp2;
				if(len4 == 0) {
					tmp2 = null;
				} else {
					var m2 = new haxe_ds_ObjectMap();
					while(--len4 > 0) m2.set(_gthis.readValue(k),_gthis.readValue(v4));
					tmp2 = m2;
				}
				return tmp2;
			}
			break;
		case 8:
			var t1 = t[2];
			var v10 = this.input.b[this.inPos++];
			if(v10 == 128) {
				v10 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len5 = v10;
			if(len5 == 0) {
				return null;
			} else {
				--len5;
				var a = [];
				var _g1 = 0;
				var _g = len5;
				while(_g1 < _g) a[_g1++] = _gthis.readValue(t1);
				return a;
			}
			break;
		case 9:
			var fields = t[2];
			var bits = this.input.b[this.inPos++];
			if(bits == 0) {
				return null;
			}
			var o = { };
			--bits;
			var _g2 = [];
			var _g11 = 0;
			while(_g11 < fields.length) {
				var f = fields[_g11];
				++_g11;
				if(this.isNullable(f.type)) {
					_g2.push(f);
				}
			}
			var nullables = _g2;
			var _g12 = 0;
			while(_g12 < fields.length) {
				var f1 = fields[_g12];
				++_g12;
				var nidx = nullables.indexOf(f1);
				if(nidx >= 0 && (bits & 1 << nidx) == 0) {
					continue;
				}
				o[f1.name] = this.readValue(f1.type);
			}
			return o;
		case 10:
			return this.readValue(t[2]);
		case 11:
			var t2 = t[2];
			var v11 = this.input.b[this.inPos++];
			if(v11 == 128) {
				v11 = this.input.getInt32(this.inPos);
				this.inPos += 4;
			}
			var len6 = v11;
			if(len6 == 0) {
				return null;
			} else {
				--len6;
				var a1 = new Array(len6);
				var _g13 = 0;
				var _g3 = len6;
				while(_g13 < _g3) a1[_g13++] = _gthis.readValue(t2);
				return a1;
			}
			break;
		case 12:
			if(this.input.b[this.inPos++] == 0) {
				return null;
			} else {
				return this.readValue(t[2]);
			}
			break;
		case 13:
			throw new js__$Boot_HaxeError("assert");
			break;
		case 14:
			return this.getDynamic();
		}
	}
	,writeValue: function(v,t) {
		var _gthis = this;
		switch(t[1]) {
		case 0:
			var v1 = v;
			if(v1 >= 0 && v1 < 128) {
				this.out.b.push(v1);
			} else {
				this.out.b.push(128);
				this.out.addInt32(v1);
			}
			break;
		case 1:
			this.out.addInt32(haxe_io_FPHelper.floatToI32(v));
			break;
		case 2:
			this.out.b.push(v?1:0);
			break;
		case 3:
			var s = v;
			if(s == null) {
				this.out.b.push(0);
			} else {
				var b = haxe_io_Bytes.ofString(s);
				var v2 = b.length + 1;
				if(v2 >= 0 && v2 < 128) {
					this.out.b.push(v2);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v2);
				}
				var _this = this.out;
				var b2 = b.b;
				var _g1 = 0;
				var _g = b.length;
				while(_g1 < _g) _this.b.push(b2[_g1++]);
			}
			break;
		case 4:
			var b1 = v;
			if(b1 == null) {
				this.out.b.push(0);
			} else {
				var v3 = b1.length + 1;
				if(v3 >= 0 && v3 < 128) {
					this.out.b.push(v3);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v3);
				}
				var _this1 = this.out;
				var b21 = b1.b;
				var _g11 = 0;
				var _g2 = b1.length;
				while(_g11 < _g2) _this1.b.push(b21[_g11++]);
			}
			break;
		case 5:
			this.addKnownRef(v);
			break;
		case 6:
			var name = t[2];
			var ser = "hxbit.enumSer." + name.split(".").join("_");
			if(ser == null) {
				throw new js__$Boot_HaxeError("No enum unserializer found for " + name);
			}
			Type.resolveClass(ser).doSerialize(this,v);
			break;
		case 7:
			var t1 = t[3];
			var k = t[2];
			var a = v;
			if(a == null) {
				this.out.b.push(0);
			} else {
				var _e = a;
				var keys = Lambda.array({ iterator : function() {
					return _e.keys();
				}});
				this.out.b.push(keys.length + 1);
				var _g3 = 0;
				while(_g3 < keys.length) {
					var k1 = keys[_g3];
					++_g3;
					_gthis.writeValue(k1,k);
					_gthis.writeValue(a.get(k1),t1);
				}
			}
			break;
		case 8:
			var t2 = t[2];
			var a1 = v;
			if(a1 == null) {
				this.out.b.push(0);
			} else {
				var v4 = a1.length + 1;
				if(v4 >= 0 && v4 < 128) {
					this.out.b.push(v4);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v4);
				}
				var _g4 = 0;
				while(_g4 < a1.length) {
					var v5 = a1[_g4];
					++_g4;
					_gthis.writeValue(v5,t2);
				}
			}
			break;
		case 9:
			var fields = t[2];
			if(v == null) {
				this.out.b.push(0);
			} else {
				var fbits = 0;
				var _g5 = [];
				var _g12 = 0;
				while(_g12 < fields.length) {
					var f = fields[_g12];
					++_g12;
					if(this.isNullable(f.type)) {
						_g5.push(f);
					}
				}
				var _g21 = 0;
				var _g13 = _g5.length;
				while(_g21 < _g13) {
					var i = _g21++;
					if(Reflect.field(v,_g5[i].name) != null) {
						fbits |= 1 << i;
					}
				}
				this.out.b.push(fbits + 1);
				var _g14 = 0;
				while(_g14 < fields.length) {
					var f1 = fields[_g14];
					++_g14;
					var nidx = _g5.indexOf(f1);
					if(nidx >= 0 && (fbits & 1 << nidx) == 0) {
						continue;
					}
					this.writeValue(Reflect.field(v,f1.name),f1.type);
				}
			}
			break;
		case 10:
			this.writeValue(v,t[2]);
			break;
		case 11:
			var t3 = t[2];
			var a2 = v;
			if(a2 == null) {
				this.out.b.push(0);
			} else {
				var v6 = a2.length + 1;
				if(v6 >= 0 && v6 < 128) {
					this.out.b.push(v6);
				} else {
					this.out.b.push(128);
					this.out.addInt32(v6);
				}
				var _g6 = 0;
				while(_g6 < a2.length) {
					var v7 = a2[_g6];
					++_g6;
					_gthis.writeValue(v7,t3);
				}
			}
			break;
		case 12:
			if(v == null) {
				this.out.b.push(0);
			} else {
				this.out.b.push(1);
				this.writeValue(v,t[2]);
			}
			break;
		case 13:
			throw new js__$Boot_HaxeError("assert");
			break;
		case 14:
			this.addDynamic(v);
			break;
		}
	}
	,__class__: hxbit_Serializer
};
var TestBitsPacket = function() {
	this.__uid = hxbit_Serializer.SEQ << 24 | ++hxbit_Serializer.UID;
	this.Arr = [];
};
$hxClasses["TestBitsPacket"] = TestBitsPacket;
TestBitsPacket.__name__ = ["TestBitsPacket"];
TestBitsPacket.__interfaces__ = [hxbit_Serializable];
TestBitsPacket.prototype = {
	getCLID: function() {
		return TestBitsPacket.__clid;
	}
	,serialize: function(__ctx) {
		var v = this.x;
		if(v >= 0 && v < 128) {
			__ctx.out.b.push(v);
		} else {
			__ctx.out.b.push(128);
			__ctx.out.addInt32(v);
		}
		var v1 = this.y;
		if(v1 >= 0 && v1 < 128) {
			__ctx.out.b.push(v1);
		} else {
			__ctx.out.b.push(128);
			__ctx.out.addInt32(v1);
		}
		var a = this.Arr;
		if(a == null) {
			__ctx.out.b.push(0);
		} else {
			var v2 = a.length + 1;
			if(v2 >= 0 && v2 < 128) {
				__ctx.out.b.push(v2);
			} else {
				__ctx.out.b.push(128);
				__ctx.out.addInt32(v2);
			}
			var _g = 0;
			while(_g < a.length) {
				var v3 = a[_g];
				++_g;
				if(v3 >= 0 && v3 < 128) {
					__ctx.out.b.push(v3);
				} else {
					__ctx.out.b.push(128);
					__ctx.out.addInt32(v3);
				}
			}
		}
	}
	,getSerializeSchema: function() {
		var schema = new hxbit_Schema();
		schema.fieldsNames.push("x");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PInt);
		schema.fieldsNames.push("y");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PInt);
		schema.fieldsNames.push("Arr");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PArray(hxbit_PropTypeDesc.PInt));
		schema.isFinal = hxbit_Serializer.isClassFinal(TestBitsPacket.__clid);
		return schema;
	}
	,unserializeInit: function() {
		this.Arr = [];
	}
	,unserialize: function(__ctx) {
		var v = __ctx.input.b[__ctx.inPos++];
		if(v == 128) {
			v = __ctx.input.getInt32(__ctx.inPos);
			__ctx.inPos += 4;
		}
		this.x = v;
		var v1 = __ctx.input.b[__ctx.inPos++];
		if(v1 == 128) {
			v1 = __ctx.input.getInt32(__ctx.inPos);
			__ctx.inPos += 4;
		}
		this.y = v1;
		var e;
		var v2 = __ctx.input.b[__ctx.inPos++];
		if(v2 == 128) {
			v2 = __ctx.input.getInt32(__ctx.inPos);
			__ctx.inPos += 4;
		}
		var len = v2;
		var tmp;
		if(len == 0) {
			tmp = null;
		} else {
			--len;
			var a = [];
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var i = _g1++;
				var v3 = __ctx.input.b[__ctx.inPos++];
				if(v3 == 128) {
					v3 = __ctx.input.getInt32(__ctx.inPos);
					__ctx.inPos += 4;
				}
				e = v3;
				a[i] = e;
			}
			tmp = a;
		}
		this.Arr = tmp;
	}
	,__class__: TestBitsPacket
};
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getSuperClass = function(c) {
	return c.__super__;
};
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum(e);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		if(a[0] != b[0]) {
			return false;
		}
		var _g1 = 2;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!Type.enumEq(a[i],b[i])) {
				return false;
			}
		}
		var e = a.__enum__;
		if(e != b.__enum__ || e == null) {
			return false;
		}
	} catch( e1 ) {
		return false;
	}
	return true;
};
var TestPacket = function() {
	this.Arr = [];
	SlimePacket.call(this);
};
$hxClasses["TestPacket"] = TestPacket;
TestPacket.__name__ = ["TestPacket"];
TestPacket.__super__ = SlimePacket;
TestPacket.prototype = $extend(SlimePacket.prototype,{
	GetName: function() {
		return "TestPacket";
	}
	,GetNames: function() {
		if([3,4,0,1,2,6,5].indexOf(0) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		if([3,4,0,1,2,6,5].indexOf(1) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		if([3,4,0,1,2,6,5].indexOf(5) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		if([3,4,0,1,2,6,5].indexOf(1) < 0) {
			throw new js__$Boot_HaxeError("Wrong value");
		}
		return [{ Name : "x", TypeInfo : { Id : 0}},{ Name : "y", TypeInfo : { Id : 1}},{ Name : "Arr", TypeInfo : { Id : 5, Param : { Id : 1}}}];
	}
	,GetValues: function() {
		var data = this.GetNames();
		var fl = [];
		var _g = 0;
		while(_g < data.length) {
			var d = data[_g];
			++_g;
			fl.push({ VarInfo : d, Value : Reflect.field(this,d.Name)});
		}
		return fl;
	}
	,ToData: function() {
		return SlimePacketParser.ToBinary(this);
	}
	,__class__: TestPacket
});
var TestSerialize = function() { };
$hxClasses["TestSerialize"] = TestSerialize;
TestSerialize.__name__ = ["TestSerialize"];
TestSerialize.main = function() {
	var items = [];
	var tm = new Date().getTime();
	var _g = 0;
	while(_g < 100000) {
		_g++;
		var pack = new TestPacket();
		pack.x = 125;
		pack.x = 125;
		pack.Arr.push(22);
		pack.Arr.push(24);
		pack.Arr.push(26);
		items.push(SlimePacketParser.FromBinary(pack.ToData()));
	}
	tm = new Date().getTime() - tm;
	console.log(tm);
	var items1 = [];
	var ser = new hxbit_Serializer();
	var tm1 = new Date().getTime();
	var _g1 = 0;
	while(_g1 < 100000) {
		_g1++;
		var pack1 = new TestBitsPacket();
		pack1.x = 125;
		pack1.y = 125;
		pack1.Arr.push(22);
		pack1.Arr.push(24);
		pack1.Arr.push(26);
		items1.push(ser.unserialize(ser.serialize(pack1),TestBitsPacket));
	}
	tm1 = new Date().getTime() - tm1;
	console.log(tm1);
};
var ValueType = { __ename__ : true, __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
var _$UInt16_UInt16_$Impl_$ = {};
$hxClasses["_UInt16.UInt16_Impl_"] = _$UInt16_UInt16_$Impl_$;
_$UInt16_UInt16_$Impl_$.__name__ = ["_UInt16","UInt16_Impl_"];
_$UInt16_UInt16_$Impl_$._new = function(v) {
	return v & 65535;
};
_$UInt16_UInt16_$Impl_$.FromInt = function(v) {
	return v & 65535;
};
var _$UInt32_UInt32_$Impl_$ = {};
$hxClasses["_UInt32.UInt32_Impl_"] = _$UInt32_UInt32_$Impl_$;
_$UInt32_UInt32_$Impl_$.__name__ = ["_UInt32","UInt32_Impl_"];
_$UInt32_UInt32_$Impl_$._new = function(v) {
	return v & -1;
};
_$UInt32_UInt32_$Impl_$.FromInt = function(v) {
	return v & -1;
};
var _$UInt8_UInt8_$Impl_$ = {};
$hxClasses["_UInt8.UInt8_Impl_"] = _$UInt8_UInt8_$Impl_$;
_$UInt8_UInt8_$Impl_$.__name__ = ["_UInt8","UInt8_Impl_"];
_$UInt8_UInt8_$Impl_$._new = function(v) {
	return v & 255;
};
_$UInt8_UInt8_$Impl_$.FromInt = function(v) {
	return v & 255;
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = ["haxe","_Int64","___Int64"];
haxe__$Int64__$_$_$Int64.prototype = {
	__class__: haxe__$Int64__$_$_$Int64
};
var haxe_Utf8 = function(size) {
	this.__b = "";
};
$hxClasses["haxe.Utf8"] = haxe_Utf8;
haxe_Utf8.__name__ = ["haxe","Utf8"];
haxe_Utf8.iter = function(s,chars) {
	var _g1 = 0;
	var _g = s.length;
	while(_g1 < _g) chars(HxOverrides.cca(s,_g1++));
};
haxe_Utf8.encode = function(s) {
	throw new js__$Boot_HaxeError("Not implemented");
};
haxe_Utf8.decode = function(s) {
	throw new js__$Boot_HaxeError("Not implemented");
};
haxe_Utf8.prototype = {
	__class__: haxe_Utf8
};
var haxe_crypto_Crc32 = function() { };
$hxClasses["haxe.crypto.Crc32"] = haxe_crypto_Crc32;
haxe_crypto_Crc32.__name__ = ["haxe","crypto","Crc32"];
haxe_crypto_Crc32.make = function(data) {
	var crc = -1;
	var b = data.b.bufferValue;
	var _g1 = 0;
	var _g = data.length;
	while(_g1 < _g) {
		var tmp = (crc ^ b.bytes[_g1++]) & 255;
		var _g2 = 0;
		while(_g2 < 8) {
			++_g2;
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
		}
		crc = crc >>> 8 ^ tmp;
	}
	return crc ^ -1;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = ["haxe","ds","ObjectMap"];
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = ["haxe","io","Bytes"];
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
haxe_io_Bytes.prototype = {
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,getString: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var s = "";
		var b = this.b;
		var fcc = String.fromCharCode;
		var i = pos;
		var max = pos + len;
		while(i < max) {
			var c = b[i++];
			if(c < 128) {
				if(c == 0) {
					break;
				}
				s += fcc(c);
			} else if(c < 224) {
				s += fcc((c & 63) << 6 | b[i++] & 127);
			} else if(c < 240) {
				s += fcc((c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127);
			} else {
				var u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
				s += fcc((u >> 10) + 55232);
				s += fcc(u & 1023 | 56320);
			}
		}
		return s;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.b = [];
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = ["haxe","io","BytesBuffer"];
haxe_io_BytesBuffer.prototype = {
	addInt32: function(v) {
		this.b.push(v & 255);
		this.b.push(v >> 8 & 255);
		this.b.push(v >> 16 & 255);
		this.b.push(v >>> 24);
	}
	,addInt64: function(v) {
		this.addInt32(v.low);
		this.addInt32(v.high);
	}
	,getBytes: function() {
		var bytes = new haxe_io_Bytes(new Uint8Array(this.b).buffer);
		this.b = null;
		return bytes;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Error = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; };
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = ["haxe","io","FPHelper"];
haxe_io_FPHelper.i32ToFloat = function(i) {
	var exp = i >>> 23 & 255;
	var sig = i & 8388607;
	if(sig == 0 && exp == 0) {
		return 0.0;
	}
	return (1 - (i >>> 31 << 1)) * (1 + Math.pow(2,-23) * sig) * Math.pow(2,exp - 127);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	if(f == 0) {
		return 0;
	}
	var af = f < 0?-f:f;
	var exp = Math.floor(Math.log(af) / 0.6931471805599453);
	if(exp < -127) {
		exp = -127;
	} else if(exp > 128) {
		exp = 128;
	}
	var sig = Math.round((af / Math.pow(2,exp) - 1) * 8388608);
	if(sig == 8388608 && exp < 128) {
		sig = 0;
		++exp;
	}
	return (f < 0?-2147483648:0) | exp + 127 << 23 | sig;
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	var exp = (high >> 20 & 2047) - 1023;
	var sig = (high & 1048575) * 4294967296. + (low >>> 31) * 2147483648. + (low & 2147483647);
	if(sig == 0 && exp == -1023) {
		return 0.0;
	}
	return (1 - (high >>> 31 << 1)) * (1.0 + Math.pow(2,-52) * sig) * Math.pow(2,exp);
};
haxe_io_FPHelper.doubleToI64 = function(v) {
	var i64 = haxe_io_FPHelper.i64tmp;
	if(v == 0) {
		i64.low = 0;
		i64.high = 0;
	} else if(!isFinite(v)) {
		if(v > 0) {
			i64.low = 0;
			i64.high = 2146435072;
		} else {
			i64.low = 0;
			i64.high = -1048576;
		}
	} else {
		var av = v < 0?-v:v;
		var exp = Math.floor(Math.log(av) / 0.6931471805599453);
		var sig = Math.round((av / Math.pow(2,exp) - 1) * 4503599627370496.);
		i64.low = sig | 0;
		i64.high = (v < 0?-2147483648:0) | exp + 1023 << 20 | (sig / 4294967296.0 | 0);
	}
	return i64;
};
var hxbit_ConvertField = function(from,to) {
	this.from = from;
	this.to = to;
};
$hxClasses["hxbit.ConvertField"] = hxbit_ConvertField;
hxbit_ConvertField.__name__ = ["hxbit","ConvertField"];
hxbit_ConvertField.prototype = {
	__class__: hxbit_ConvertField
};
var hxbit_Convert = function(ourSchema,schema) {
	var ourMap = new haxe_ds_StringMap();
	var _g1 = 0;
	var _g = ourSchema.fieldsNames.length;
	while(_g1 < _g) {
		var i = _g1++;
		var key = ourSchema.fieldsNames[i];
		var value = ourSchema.fieldsTypes[i];
		if(__map_reserved[key] != null) {
			ourMap.setReserved(key,value);
		} else {
			ourMap.h[key] = value;
		}
	}
	this.read = [];
	if(ourSchema.isFinal != schema.isFinal) {
		throw new js__$Boot_HaxeError("TODO : handle final flag change");
	}
	var map = new haxe_ds_StringMap();
	var _g11 = 0;
	var _g2 = schema.fieldsNames.length;
	while(_g11 < _g2) {
		var i1 = _g11++;
		var oldT = schema.fieldsTypes[i1];
		var key1 = schema.fieldsNames[i1];
		var newT = __map_reserved[key1] != null?ourMap.getReserved(key1):ourMap.h[key1];
		var c = new hxbit_ConvertField(oldT,newT);
		if(newT != null) {
			if(hxbit_Convert.sameType(oldT,newT)) {
				c.same = true;
			} else {
				c.defaultValue = hxbit_Convert.getDefault(newT);
			}
		}
		c.index = this.read.length;
		this.read.push(c);
		var key2 = schema.fieldsNames[i1];
		if(__map_reserved[key2] != null) {
			map.setReserved(key2,c);
		} else {
			map.h[key2] = c;
		}
	}
	this.write = [];
	var _g12 = 0;
	var _g3 = ourSchema.fieldsNames.length;
	while(_g12 < _g3) {
		var i2 = _g12++;
		var newT1 = ourSchema.fieldsTypes[i2];
		var key3 = ourSchema.fieldsNames[i2];
		var c1 = __map_reserved[key3] != null?map.getReserved(key3):map.h[key3];
		if(c1 == null) {
			c1 = new hxbit_ConvertField(null,newT1);
			c1.defaultValue = hxbit_Convert.getDefault(newT1);
		}
		this.write.push(c1);
	}
};
$hxClasses["hxbit.Convert"] = hxbit_Convert;
hxbit_Convert.__name__ = ["hxbit","Convert"];
hxbit_Convert.sameType = function(a,b) {
	switch(a[1]) {
	case 7:
		switch(b[1]) {
		case 7:
			if(hxbit_Convert.sameType(a[2],b[2])) {
				return hxbit_Convert.sameType(a[3],b[3]);
			} else {
				return false;
			}
			break;
		case 10:
			return hxbit_Convert.sameType(a,b[2]);
		default:
			return Type.enumEq(a,b);
		}
		break;
	case 8:
		switch(b[1]) {
		case 8:
			return hxbit_Convert.sameType(a[2],b[2]);
		case 10:
			return hxbit_Convert.sameType(a,b[2]);
		default:
			return Type.enumEq(a,b);
		}
		break;
	case 9:
		switch(b[1]) {
		case 9:
			var fa = a[2];
			var fb = b[2];
			if(fa.length != fb.length) {
				return false;
			}
			var _g1 = 0;
			var _g = fa.length;
			while(_g1 < _g) {
				var i = _g1++;
				var a1 = fa[i];
				var b1 = fb[i];
				if(a1.name != b1.name || a1.opt != b1.opt || !hxbit_Convert.sameType(a1.type,b1.type)) {
					return false;
				}
			}
			return true;
		case 10:
			return hxbit_Convert.sameType(a,b[2]);
		default:
			return Type.enumEq(a,b);
		}
		break;
	case 10:
		if(b[1] == 10) {
			return hxbit_Convert.sameType(a[2],b[2]);
		} else {
			return hxbit_Convert.sameType(a[2],b);
		}
		break;
	case 11:
		switch(b[1]) {
		case 10:
			return hxbit_Convert.sameType(a,b[2]);
		case 11:
			return hxbit_Convert.sameType(a[2],b[2]);
		default:
			return Type.enumEq(a,b);
		}
		break;
	case 12:
		switch(b[1]) {
		case 10:
			return hxbit_Convert.sameType(a,b[2]);
		case 12:
			return hxbit_Convert.sameType(a[2],b[2]);
		default:
			return Type.enumEq(a,b);
		}
		break;
	default:
		if(b[1] == 10) {
			return hxbit_Convert.sameType(a,b[2]);
		} else {
			return Type.enumEq(a,b);
		}
	}
};
hxbit_Convert.getDefault = function(t) {
	switch(t[1]) {
	case 0:
		return 0;
	case 1:
		return 0.;
	case 2:
		return false;
	case 7:
		switch(t[2][1]) {
		case 0:
			return new haxe_ds_IntMap();
		case 3:
			return new haxe_ds_StringMap();
		default:
			return new haxe_ds_ObjectMap();
		}
		break;
	case 8:
		return [];
	case 10:
		return hxbit_Convert.getDefault(t[2]);
	case 11:
		return new Array(0);
	case 3:case 4:case 5:case 6:case 9:case 12:case 13:case 14:
		return null;
	}
};
hxbit_Convert.prototype = {
	__class__: hxbit_Convert
};
var hxbit_RpcMode = { __ename__ : true, __constructs__ : ["All","Client","Server","Owner"] };
hxbit_RpcMode.All = ["All",0];
hxbit_RpcMode.All.toString = $estr;
hxbit_RpcMode.All.__enum__ = hxbit_RpcMode;
hxbit_RpcMode.Client = ["Client",1];
hxbit_RpcMode.Client.toString = $estr;
hxbit_RpcMode.Client.__enum__ = hxbit_RpcMode;
hxbit_RpcMode.Server = ["Server",2];
hxbit_RpcMode.Server.toString = $estr;
hxbit_RpcMode.Server.__enum__ = hxbit_RpcMode;
hxbit_RpcMode.Owner = ["Owner",3];
hxbit_RpcMode.Owner.toString = $estr;
hxbit_RpcMode.Owner.__enum__ = hxbit_RpcMode;
var hxbit_PropTypeDesc = { __ename__ : true, __constructs__ : ["PInt","PFloat","PBool","PString","PBytes","PSerializable","PEnum","PMap","PArray","PObj","PAlias","PVector","PNull","PUnknown","PDynamic"] };
hxbit_PropTypeDesc.PInt = ["PInt",0];
hxbit_PropTypeDesc.PInt.toString = $estr;
hxbit_PropTypeDesc.PInt.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PFloat = ["PFloat",1];
hxbit_PropTypeDesc.PFloat.toString = $estr;
hxbit_PropTypeDesc.PFloat.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PBool = ["PBool",2];
hxbit_PropTypeDesc.PBool.toString = $estr;
hxbit_PropTypeDesc.PBool.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PString = ["PString",3];
hxbit_PropTypeDesc.PString.toString = $estr;
hxbit_PropTypeDesc.PString.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PBytes = ["PBytes",4];
hxbit_PropTypeDesc.PBytes.toString = $estr;
hxbit_PropTypeDesc.PBytes.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PSerializable = function(name) { var $x = ["PSerializable",5,name]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PEnum = function(name) { var $x = ["PEnum",6,name]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PMap = function(k,v) { var $x = ["PMap",7,k,v]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PArray = function(k) { var $x = ["PArray",8,k]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PObj = function(fields) { var $x = ["PObj",9,fields]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PAlias = function(k) { var $x = ["PAlias",10,k]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PVector = function(k) { var $x = ["PVector",11,k]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PNull = function(t) { var $x = ["PNull",12,t]; $x.__enum__ = hxbit_PropTypeDesc; $x.toString = $estr; return $x; };
hxbit_PropTypeDesc.PUnknown = ["PUnknown",13];
hxbit_PropTypeDesc.PUnknown.toString = $estr;
hxbit_PropTypeDesc.PUnknown.__enum__ = hxbit_PropTypeDesc;
hxbit_PropTypeDesc.PDynamic = ["PDynamic",14];
hxbit_PropTypeDesc.PDynamic.toString = $estr;
hxbit_PropTypeDesc.PDynamic.__enum__ = hxbit_PropTypeDesc;
var hxbit_Macros = function() { };
$hxClasses["hxbit.Macros"] = hxbit_Macros;
hxbit_Macros.__name__ = ["hxbit","Macros"];
var hxbit_Schema = function() {
	this.__uid = hxbit_Serializer.SEQ << 24 | ++hxbit_Serializer.UID;
	this.fieldsNames = [];
	this.fieldsTypes = [];
};
$hxClasses["hxbit.Schema"] = hxbit_Schema;
hxbit_Schema.__name__ = ["hxbit","Schema"];
hxbit_Schema.__interfaces__ = [hxbit_Serializable];
hxbit_Schema.prototype = {
	get_checkSum: function() {
		var s = new hxbit_Serializer();
		s.begin();
		var old = this.__uid;
		this.__uid = 0;
		s.addKnownRef(this);
		this.__uid = old;
		return haxe_crypto_Crc32.make(s.end());
	}
	,getCLID: function() {
		return hxbit_Schema.__clid;
	}
	,serialize: function(__ctx) {
		__ctx.out.b.push(this.isFinal?1:0);
		var a = this.fieldsNames;
		if(a == null) {
			__ctx.out.b.push(0);
		} else {
			var v = a.length + 1;
			if(v >= 0 && v < 128) {
				__ctx.out.b.push(v);
			} else {
				__ctx.out.b.push(128);
				__ctx.out.addInt32(v);
			}
			var _g = 0;
			while(_g < a.length) {
				var v1 = a[_g];
				++_g;
				if(v1 == null) {
					__ctx.out.b.push(0);
				} else {
					var b = haxe_io_Bytes.ofString(v1);
					var v2 = b.length + 1;
					if(v2 >= 0 && v2 < 128) {
						__ctx.out.b.push(v2);
					} else {
						__ctx.out.b.push(128);
						__ctx.out.addInt32(v2);
					}
					var _this = __ctx.out;
					var b2 = b.b;
					var _g1 = 0;
					var _g2 = b.length;
					while(_g1 < _g2) _this.b.push(b2[_g1++]);
				}
			}
		}
		var a1 = this.fieldsTypes;
		if(a1 == null) {
			__ctx.out.b.push(0);
		} else {
			var v3 = a1.length + 1;
			if(v3 >= 0 && v3 < 128) {
				__ctx.out.b.push(v3);
			} else {
				__ctx.out.b.push(128);
				__ctx.out.addInt32(v3);
			}
			var _g3 = 0;
			while(_g3 < a1.length) {
				var v4 = a1[_g3];
				++_g3;
				hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(__ctx,v4);
			}
		}
	}
	,getSerializeSchema: function() {
		var schema = new hxbit_Schema();
		schema.fieldsNames.push("isFinal");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PBool);
		schema.fieldsNames.push("fieldsNames");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PArray(hxbit_PropTypeDesc.PString));
		schema.fieldsNames.push("fieldsTypes");
		schema.fieldsTypes.push(hxbit_PropTypeDesc.PArray(hxbit_PropTypeDesc.PEnum("hxbit.PropTypeDesc")));
		schema.isFinal = hxbit_Serializer.isClassFinal(hxbit_Schema.__clid);
		return schema;
	}
	,unserializeInit: function() {
	}
	,unserialize: function(__ctx) {
		this.isFinal = __ctx.input.b[__ctx.inPos++] != 0;
		var e;
		var v = __ctx.input.b[__ctx.inPos++];
		if(v == 128) {
			v = __ctx.input.getInt32(__ctx.inPos);
			__ctx.inPos += 4;
		}
		var len = v;
		var tmp;
		if(len == 0) {
			tmp = null;
		} else {
			--len;
			var a = [];
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var i = _g1++;
				var v1 = __ctx.input.b[__ctx.inPos++];
				if(v1 == 128) {
					v1 = __ctx.input.getInt32(__ctx.inPos);
					__ctx.inPos += 4;
				}
				var len1 = v1;
				if(len1 == 0) {
					e = null;
				} else {
					--len1;
					var s = __ctx.input.getString(__ctx.inPos,len1);
					__ctx.inPos += len1;
					e = s;
				}
				a[i] = e;
			}
			tmp = a;
		}
		this.fieldsNames = tmp;
		var e1;
		var v2 = __ctx.input.b[__ctx.inPos++];
		if(v2 == 128) {
			v2 = __ctx.input.getInt32(__ctx.inPos);
			__ctx.inPos += 4;
		}
		var len2 = v2;
		var tmp1;
		if(len2 == 0) {
			tmp1 = null;
		} else {
			--len2;
			var a1 = [];
			var _g11 = 0;
			var _g2 = len2;
			while(_g11 < _g2) {
				e1 = hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(__ctx);
				a1[_g11++] = e1;
			}
			tmp1 = a1;
		}
		this.fieldsTypes = tmp1;
	}
	,__class__: hxbit_Schema
};
var hxbit_SerializableEnum = function() { };
$hxClasses["hxbit.SerializableEnum"] = hxbit_SerializableEnum;
hxbit_SerializableEnum.__name__ = ["hxbit","SerializableEnum"];
var hxbit_enumSer_hxbit_$PropTypeDesc = function() { };
$hxClasses["hxbit.enumSer.hxbit_PropTypeDesc"] = hxbit_enumSer_hxbit_$PropTypeDesc;
hxbit_enumSer_hxbit_$PropTypeDesc.__name__ = ["hxbit","enumSer","hxbit_PropTypeDesc"];
hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize = function(ctx,v) {
	if(v == null) {
		ctx.out.b.push(0);
	} else {
		switch(v[1]) {
		case 0:
			ctx.out.b.push(1);
			break;
		case 1:
			ctx.out.b.push(2);
			break;
		case 2:
			ctx.out.b.push(3);
			break;
		case 3:
			ctx.out.b.push(4);
			break;
		case 4:
			ctx.out.b.push(5);
			break;
		case 5:
			var name = v[2];
			ctx.out.b.push(6);
			if(name == null) {
				ctx.out.b.push(0);
			} else {
				var b = haxe_io_Bytes.ofString(name);
				var v1 = b.length + 1;
				if(v1 >= 0 && v1 < 128) {
					ctx.out.b.push(v1);
				} else {
					ctx.out.b.push(128);
					ctx.out.addInt32(v1);
				}
				var _this = ctx.out;
				var b2 = b.b;
				var _g1 = 0;
				var _g = b.length;
				while(_g1 < _g) _this.b.push(b2[_g1++]);
			}
			break;
		case 6:
			var name1 = v[2];
			ctx.out.b.push(7);
			if(name1 == null) {
				ctx.out.b.push(0);
			} else {
				var b1 = haxe_io_Bytes.ofString(name1);
				var v2 = b1.length + 1;
				if(v2 >= 0 && v2 < 128) {
					ctx.out.b.push(v2);
				} else {
					ctx.out.b.push(128);
					ctx.out.addInt32(v2);
				}
				var _this1 = ctx.out;
				var b21 = b1.b;
				var _g11 = 0;
				var _g2 = b1.length;
				while(_g11 < _g2) _this1.b.push(b21[_g11++]);
			}
			break;
		case 7:
			ctx.out.b.push(8);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[2]);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[3]);
			break;
		case 8:
			ctx.out.b.push(9);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[2]);
			break;
		case 9:
			var fields = v[2];
			ctx.out.b.push(10);
			if(fields == null) {
				ctx.out.b.push(0);
			} else {
				var v3 = fields.length + 1;
				if(v3 >= 0 && v3 < 128) {
					ctx.out.b.push(v3);
				} else {
					ctx.out.b.push(128);
					ctx.out.addInt32(v3);
				}
				var _g3 = 0;
				while(_g3 < fields.length) {
					var v4 = fields[_g3];
					++_g3;
					if(v4 == null) {
						ctx.out.b.push(0);
					} else {
						var fbits = 0;
						if(v4.name != null) {
							fbits = 1;
						}
						if(v4.type != null) {
							fbits |= 2;
						}
						var v5 = fbits + 1;
						if(v5 >= 0 && v5 < 128) {
							ctx.out.b.push(v5);
						} else {
							ctx.out.b.push(128);
							ctx.out.addInt32(v5);
						}
						if((fbits & 1) != 0) {
							var s = v4.name;
							if(s == null) {
								ctx.out.b.push(0);
							} else {
								var b3 = haxe_io_Bytes.ofString(s);
								var v6 = b3.length + 1;
								if(v6 >= 0 && v6 < 128) {
									ctx.out.b.push(v6);
								} else {
									ctx.out.b.push(128);
									ctx.out.addInt32(v6);
								}
								var _this2 = ctx.out;
								var b22 = b3.b;
								var _g12 = 0;
								var _g4 = b3.length;
								while(_g12 < _g4) _this2.b.push(b22[_g12++]);
							}
						}
						ctx.out.b.push(v4.opt?1:0);
						if((fbits & 2) != 0) {
							hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v4.type);
						}
					}
				}
			}
			break;
		case 10:
			ctx.out.b.push(11);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[2]);
			break;
		case 11:
			ctx.out.b.push(12);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[2]);
			break;
		case 12:
			ctx.out.b.push(13);
			hxbit_enumSer_hxbit_$PropTypeDesc.doSerialize(ctx,v[2]);
			break;
		case 13:
			ctx.out.b.push(14);
			break;
		case 14:
			ctx.out.b.push(15);
			break;
		}
	}
};
hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize = function(ctx) {
	var b = ctx.input.b[ctx.inPos++];
	if(b == 0) {
		return null;
	}
	switch(b) {
	case 1:
		return hxbit_PropTypeDesc.PInt;
	case 2:
		return hxbit_PropTypeDesc.PFloat;
	case 3:
		return hxbit_PropTypeDesc.PBool;
	case 4:
		return hxbit_PropTypeDesc.PString;
	case 5:
		return hxbit_PropTypeDesc.PBytes;
	case 6:
		var _name;
		var v = ctx.input.b[ctx.inPos++];
		if(v == 128) {
			v = ctx.input.getInt32(ctx.inPos);
			ctx.inPos += 4;
		}
		var len = v;
		if(len == 0) {
			_name = null;
		} else {
			--len;
			var s = ctx.input.getString(ctx.inPos,len);
			ctx.inPos += len;
			_name = s;
		}
		return hxbit_PropTypeDesc.PSerializable(_name);
	case 7:
		var _name1;
		var v1 = ctx.input.b[ctx.inPos++];
		if(v1 == 128) {
			v1 = ctx.input.getInt32(ctx.inPos);
			ctx.inPos += 4;
		}
		var len1 = v1;
		if(len1 == 0) {
			_name1 = null;
		} else {
			--len1;
			var s1 = ctx.input.getString(ctx.inPos,len1);
			ctx.inPos += len1;
			_name1 = s1;
		}
		return hxbit_PropTypeDesc.PEnum(_name1);
	case 8:
		return hxbit_PropTypeDesc.PMap(hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx),hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx));
	case 9:
		return hxbit_PropTypeDesc.PArray(hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx));
	case 10:
		var _fields;
		var e;
		var v2 = ctx.input.b[ctx.inPos++];
		if(v2 == 128) {
			v2 = ctx.input.getInt32(ctx.inPos);
			ctx.inPos += 4;
		}
		var len2 = v2;
		if(len2 == 0) {
			_fields = null;
		} else {
			--len2;
			var a = [];
			var _g1 = 0;
			var _g = len2;
			while(_g1 < _g) {
				var i = _g1++;
				var v3 = ctx.input.b[ctx.inPos++];
				if(v3 == 128) {
					v3 = ctx.input.getInt32(ctx.inPos);
					ctx.inPos += 4;
				}
				var fbits = v3;
				if(fbits == 0) {
					e = null;
				} else {
					--fbits;
					var type = null;
					var opt;
					var name = null;
					if((fbits & 1) != 0) {
						var v4 = ctx.input.b[ctx.inPos++];
						if(v4 == 128) {
							v4 = ctx.input.getInt32(ctx.inPos);
							ctx.inPos += 4;
						}
						var len3 = v4;
						if(len3 == 0) {
							name = null;
						} else {
							--len3;
							var s2 = ctx.input.getString(ctx.inPos,len3);
							ctx.inPos += len3;
							name = s2;
						}
					}
					opt = ctx.input.b[ctx.inPos++] != 0;
					if((fbits & 2) != 0) {
						type = hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx);
					}
					e = { name : name, opt : opt, type : type};
				}
				a[i] = e;
			}
			_fields = a;
		}
		return hxbit_PropTypeDesc.PObj(_fields);
	case 11:
		return hxbit_PropTypeDesc.PAlias(hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx));
	case 12:
		return hxbit_PropTypeDesc.PVector(hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx));
	case 13:
		return hxbit_PropTypeDesc.PNull(hxbit_enumSer_hxbit_$PropTypeDesc.doUnserialize(ctx));
	case 14:
		return hxbit_PropTypeDesc.PUnknown;
	case 15:
		return hxbit_PropTypeDesc.PDynamic;
	default:
		throw new js__$Boot_HaxeError("Invalid enum index " + b);
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0?",":"") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = intf[_g1++];
			if(i == cl || js_Boot.__interfLoop(i,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class?o.__name__ != null:false) {
			return true;
		}
		if(cl == Enum?o.__ename__ != null:false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) this.a[_g1++] = 0;
		this.byteLength = len;
	}
};
$hxClasses["js.html.compat.ArrayBuffer"] = js_html_compat_ArrayBuffer;
js_html_compat_ArrayBuffer.__name__ = ["js","html","compat","ArrayBuffer"];
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null?null:end - begin);
	var result = new ArrayBuffer(u.byteLength);
	new Uint8Array(result).set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_DataView = function(buffer,byteOffset,byteLength) {
	this.buf = buffer;
	this.offset = byteOffset == null?0:byteOffset;
	this.length = byteLength == null?buffer.byteLength - this.offset:byteLength;
	if(this.offset < 0 || this.length < 0 || this.offset + this.length > buffer.byteLength) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.byteLength = this.length;
	this.byteOffset = this.offset;
	this.buffer = this.buf;
};
$hxClasses["js.html.compat.DataView"] = js_html_compat_DataView;
js_html_compat_DataView.__name__ = ["js","html","compat","DataView"];
js_html_compat_DataView.prototype = {
	getInt8: function(byteOffset) {
		var v = this.buf.a[this.offset + byteOffset];
		if(v >= 128) {
			return v - 256;
		} else {
			return v;
		}
	}
	,getUint8: function(byteOffset) {
		return this.buf.a[this.offset + byteOffset];
	}
	,getInt16: function(byteOffset,littleEndian) {
		var v = this.getUint16(byteOffset,littleEndian);
		if(v >= 32768) {
			return v - 65536;
		} else {
			return v;
		}
	}
	,getUint16: function(byteOffset,littleEndian) {
		if(littleEndian) {
			return this.buf.a[this.offset + byteOffset] | this.buf.a[this.offset + byteOffset + 1] << 8;
		} else {
			return this.buf.a[this.offset + byteOffset] << 8 | this.buf.a[this.offset + byteOffset + 1];
		}
	}
	,getInt32: function(byteOffset,littleEndian) {
		var p = this.offset + byteOffset;
		var a = this.buf.a[p++];
		var b = this.buf.a[p++];
		var c = this.buf.a[p++];
		var d = this.buf.a[p++];
		if(littleEndian) {
			return a | b << 8 | c << 16 | d << 24;
		} else {
			return d | c << 8 | b << 16 | a << 24;
		}
	}
	,getUint32: function(byteOffset,littleEndian) {
		var v = this.getInt32(byteOffset,littleEndian);
		if(v < 0) {
			return v + 4294967296.;
		} else {
			return v;
		}
	}
	,getFloat32: function(byteOffset,littleEndian) {
		return haxe_io_FPHelper.i32ToFloat(this.getInt32(byteOffset,littleEndian));
	}
	,getFloat64: function(byteOffset,littleEndian) {
		var a = this.getInt32(byteOffset,littleEndian);
		var b = this.getInt32(byteOffset + 4,littleEndian);
		return haxe_io_FPHelper.i64ToDouble(littleEndian?a:b,littleEndian?b:a);
	}
	,setInt8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value < 0?value + 128 & 255:value & 255;
	}
	,setUint8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value & 255;
	}
	,setInt16: function(byteOffset,value,littleEndian) {
		this.setUint16(byteOffset,value < 0?value + 65536:value,littleEndian);
	}
	,setUint16: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
		} else {
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p] = value & 255;
		}
	}
	,setInt32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,value,littleEndian);
	}
	,setUint32: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p++] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >>> 24;
		} else {
			this.buf.a[p++] = value >>> 24;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value & 255;
		}
	}
	,setFloat32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,haxe_io_FPHelper.floatToI32(value),littleEndian);
	}
	,setFloat64: function(byteOffset,value,littleEndian) {
		var i64 = haxe_io_FPHelper.doubleToI64(value);
		if(littleEndian) {
			this.setUint32(byteOffset,i64.low);
			this.setUint32(byteOffset,i64.high);
		} else {
			this.setUint32(byteOffset,i64.high);
			this.setUint32(byteOffset,i64.low);
		}
	}
	,__class__: js_html_compat_DataView
};
var js_html_compat_Uint8Array = function() { };
$hxClasses["js.html.compat.Uint8Array"] = js_html_compat_Uint8Array;
js_html_compat_Uint8Array.__name__ = ["js","html","compat","Uint8Array"];
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
$hxClasses["Math"] = Math;
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = ["String"];
$hxClasses["Array"] = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses["Int"] = { __name__ : ["Int"]};
var Dynamic = $hxClasses["Dynamic"] = { __name__ : ["Dynamic"]};
var Float = $hxClasses["Float"] = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses["Class"] = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {}
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var DataView = $global.DataView || js_html_compat_DataView;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
_$KnownType_KnownType_$Impl_$.UINT8 = 0;
_$KnownType_KnownType_$Impl_$.UINT16 = 1;
_$KnownType_KnownType_$Impl_$.UINT32 = 2;
_$KnownType_KnownType_$Impl_$.INT = 3;
_$KnownType_KnownType_$Impl_$.STRING = 4;
_$KnownType_KnownType_$Impl_$.ARRAY = 5;
_$KnownType_KnownType_$Impl_$.SLIME_PACKET = 6;
_$KnownType_KnownType_$Impl_$.UINT8_STR = "UInt8";
_$KnownType_KnownType_$Impl_$.UINT16_STR = "UInt16";
_$KnownType_KnownType_$Impl_$.UINT32_STR = "UInt32";
_$KnownType_KnownType_$Impl_$.INT_STR = "Int";
_$KnownType_KnownType_$Impl_$.STRING_STR = "String";
_$KnownType_KnownType_$Impl_$.ARRAY_STR = "Array";
_$KnownType_KnownType_$Impl_$.SLIME_PACKET_STR = "SlimePacket";
SlimePacketParser.NULL = 255;
SlimePacketParser.ARRAY = 1;
SlimePacketParser.STRUCTURE = 2;
SlimePacketParser.UINT8 = 3;
SlimePacketParser.UINT16 = 4;
SlimePacketParser.UINT32 = 5;
SlimePacketParser._counter = 0;
SlimePacketParser._knownPackets = new haxe_ds_StringMap();
SlimePacketParser._knownPacketsResolved = new haxe_ds_IntMap();
hxbit_Serializer.UID = 0;
hxbit_Serializer.SEQ = 0;
hxbit_Serializer.SEQ_BITS = 8;
hxbit_Serializer.SEQ_MASK = 16777215;
hxbit_Serializer.CLASSES = [];
TestBitsPacket.__clid = hxbit_Serializer.registerClass(TestBitsPacket);
TestPacket.__meta__ = { fields : { x : { Serialize : null}, y : { Serialize : null}, Arr : { Serialize : null}}};
TestPacket._register = SlimePacketParser.Register("TestPacket");
haxe_ds_ObjectMap.count = 0;
haxe_io_FPHelper.i64tmp = new haxe__$Int64__$_$_$Int64(0,0);
hxbit_Macros.IN_ENUM_SER = false;
hxbit_Schema.__clid = hxbit_Serializer.registerClass(hxbit_Schema);
js_Boot.__toStr = ({ }).toString;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
TestSerialize.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
